# A01_data_cleaning.R
# Purpose: robustly parse and clean world_real_estate_data.csv
# Outputs:
# - members/member_A_data/cleaned_data.csv
# - members/member_A_data/cleaning_report.txt

library(readr)
library(dplyr)
library(stringr)
library(lubridate)

# Paths (adjust if running from different working dir)
raw_path <- "C:/Users/User/Downloads/team data/team 156/world_real_estate_data(147k).csv"
out_dir <- 'C:/Users/User/Downloads/team data/team 156/complete_project/members/member_A_data'
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
clean_path <- file.path(out_dir, "cleaned_data.csv")

# Read raw (try to auto-detect)
df_raw <- read_csv(raw_path, guess_max = 20000, show_col_types = FALSE, col_types = cols(.default = col_character()))

# Copy of original cols for reporting
orig_nrow <- nrow(df_raw)
orig_cols <- names(df_raw)

# Helper to parse numeric from strings like "110 mÂ²", "1,200", "1 200"
parse_num <- function(x) {
  x2 <- as.character(x)
  x2 <- str_replace_all(x2, "\\s+", "")        # remove spaces
  x2 <- str_replace_all(x2, ",", ".")          # comma -> dot
  # Extract the first valid number pattern to avoid coercion warnings
  num_str <- str_extract(x2, "-?\\d+\\.?\\d*")
  as.numeric(num_str)
}

df <- df_raw %>%
  mutate(
    apartment_living_area_raw = coalesce(apartment_living_area, location, NA_character_),
    apartment_living_area_sqm = parse_num(apartment_living_area_raw),
    price_in_USD = parse_num(price_in_USD),
    # fallback columns
    country = coalesce(country, location, NA_character_)
  )

# Report initial NA counts
na_before <- sapply(df[c("apartment_living_area_sqm","price_in_USD")], function(x) sum(is.na(x)))
